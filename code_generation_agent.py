# import httpx
import json
from langchain.pydantic_v1 import BaseModel, Field
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langgraph.graph import END, StateGraph, START
from typing import List, TypedDict
from langchain.output_parsers import PydanticOutputParser
from nbexecutor import NBExecutor
from utils import exec_in_venv
""" 
TODO
- [ ]:  get it to make obey in form of conversational format of code and outputs like assistant human format no just in a single prompt
# - HACK gdfgfdgdf

"""


class Code(BaseModel):
    """
    Represents a code solution generated by the AI assistant.

    This model encapsulates the three main components of a code solution:
    imports, main code, and description. It is designed to ensure that all
    necessary parts of a complete code solution are present and well-structured.

    Attributes:
        imports (str): A string containing all necessary import statements for the solution.
                       This should include all libraries and modules required to run the main code.

        code (str): The main body of the code solution. This should be executable Python code
                    that implements the requested functionality. Default is a placeholder comment.

        description (str): A brief explanation of what the code does, how it works, and any
                           important considerations or assumptions made in the implementation.

    Example:
        ```python
        solution = Code(
            imports="import numpy as np\nfrom sklearn.model_selection import train_test_split",
            code="def preprocess_data(X, y):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n    return X_train, X_test, y_train, y_test",
            description="This function preprocesses the input data by splitting it into training and testing sets using an 80-20 split ratio."
        )
        ```

    Note:
        All fields are required to be non-empty when creating a Code instance.
        The 'code' field has a default value to ensure it's always present, even if empty.
    """

    imports: str = Field(description="Imports required for the solution.")
    code: str = Field(description="Code for the solution", default="#no Code for this task")
    description: str = Field(description="Description for the solution.")

class GraphState(TypedDict):
    error: str
    messages: List
    generation: Code
    iterations: int
    context: str

class CodeGenerationAgent:
    def __init__(self, config, proxy,nb_executor:NBExecutor, model="gpt-4o-mini", max_iterations=3):
        self.max_iterations = max_iterations
        self.config = config
        self.nb_executor=nb_executor
        self.llm = ChatOpenAI(model=model, http_client=proxy, temperature=0)
        self.code_gen_prompt = ChatPromptTemplate.from_messages([
            (
                "system",
                """You are an expert Python coding assistant specialized in machine learning and data science tasks. Your role is to generate high-quality, executable Python code based on the given context and user request. Follow these guidelines:

                1. Context Understanding:
                   Analyze the following context carefully:
                   ------- 
                   {context}
                   -------
                   Use this context to inform your code generation, ensuring relevance and appropriateness.

                2. Code Structure:
                   Organize your response in three distinct sections:
                   a) Imports: List all necessary library imports.
                   b) Main Code: Provide the primary implementation.
                   c) Description: Briefly explain the code's functionality and any important considerations.

                3. Code Quality:
                   - Ensure all variables are properly defined before use.
                   - Follow PEP 8 style guidelines for clean, readable code.
                   - Include comments for complex operations or non-obvious logic.
                   - Handle potential errors or edge cases where appropriate.

                4. Machine Learning Best Practices:
                   - If applicable, include data preprocessing steps.
                   - Consider data splitting for training and testing.
                   - Implement appropriate model evaluation metrics.

                5. Output Format:
                   Adhere strictly to the following output format:
                   {format_instructions}

                6. Execution Ready:
                   The code must be immediately executable without modifications.

                7. Completeness:
                   Ensure all three sections (imports, code, and description) are present and non-empty.

                Remember, your goal is to provide a comprehensive, error-free, and executable solution that directly addresses the user's request while considering the given context.
                """
            ),
            ("human", "{messages}"),
        ])
        self.output_parser = PydanticOutputParser(pydantic_object=Code)
        self.format_instructions = self.output_parser.get_format_instructions()
        self.code_gen_chain = self.code_gen_prompt | self.llm | self.output_parser
        self.workflow = self.create_workflow()

    def generate(self, state: GraphState):
        print("---GENERATING CODE SOLUTION---")
        messages = state["messages"]
        iterations = state["iterations"]
        error = state["error"]

        if error == "yes":
            messages += [
                (
                    "human",
                    "The previous solution had errors. Please try again, ensuring all imports are correct and the code is executable.",
                )
            ]
        # with open("x.json", "w", encoding="utf8") as f:    
        #     json.dump({"context": state["context"], "messages": messages[-1][1], "format_instructions": self.format_instructions}, f, indent=2)
        
        code_solution = self.code_gen_chain.invoke(
            {"context": state["context"], "messages": messages[-1][1], "format_instructions": self.format_instructions},
            config=self.config
        )
        
        # Ensure all fields are present in the Code object
        code_solution_dict = code_solution.dict()
        for field in ["imports", "code", "description"]:
            if field not in code_solution_dict or code_solution_dict[field] is None:
                code_solution_dict[field] = ""  # Set to empty string if missing
        
        code_solution = Code(**code_solution_dict)

        messages += [
            (
                "assistant",
                f"Imports:\n{code_solution.imports}\nCode:\n{code_solution.code}\nDescription:\n{code_solution.description}",
            )
        ]

        iterations = iterations + 1
        return {"generation": code_solution, "messages": messages, "iterations": iterations}


    def code_check(self, state: GraphState):
        print("---CHECKING CODE---")
        messages = state["messages"]
        code_solution = state["generation"]
        iterations = state["iterations"]

        imports = code_solution.imports
        code = code_solution.code

        try:
            self.nb_executor.test_and_execute(imports)
            # exec_in_venv(imports)
            self.nb_executor.test_and_execute(imports + "\n" + code)
            
            
            print("---NO CODE TEST FAILURES---")
            return {
                "generation": code_solution,
                "messages": messages,
                "iterations": iterations,
                "error": "no",
            }
        except Exception as e:
            print(f"---CODE CHECK FAILED: {str(e)}---")
            error_message = [("human", f"Your solution failed with the following error: {str(e)}")]
            messages += error_message
            return {
                "generation": code_solution,
                "messages": messages,
                "iterations": iterations,
                "error": "yes",
            }

    def decide_to_finish(self, state: GraphState):
        error = state["error"]
        iterations = state["iterations"]

        if error == "no" or iterations == self.max_iterations:
            print("---DECISION: FINISH---")
            return "end"
        else:
            print("---DECISION: RE-TRY SOLUTION---")
            return "generate"

    def create_workflow(self):
        workflow = StateGraph(GraphState)
        workflow.add_node("generate", self.generate)
        workflow.add_node("check_code", self.code_check)
        workflow.add_edge(START, "generate")
        workflow.add_edge("generate", "check_code")
        workflow.add_conditional_edges(
            "check_code",
            self.decide_to_finish,
            {
                "end": END,
                "generate": "generate",
            },
        )
        return workflow.compile()

    def generate_code(self, context: str, task: str) -> Code:
            initial_state = {
                "messages": [("human", task)],
                "iterations": 0,
                "context": context,
                "error": "no",
                "generation": Code(imports="", code="", description="")  # Initialize with empty Code
            }
            result = self.workflow.invoke(initial_state, config=self.config)
            return result["generation"]
# Usage example
if __name__ == "__main__":
    agent = CodeGenerationAgent()
    
    context = "We are working on a Kaggle problem involving image classification."
    task = "Create a function to load and preprocess image data using PIL and numpy."
    final_code = agent.generate_code(context, task)
    print(f"Imports:\n{final_code.imports}\n\nCode:\n{final_code.code}\n\nDescription:\n{final_code.description}")